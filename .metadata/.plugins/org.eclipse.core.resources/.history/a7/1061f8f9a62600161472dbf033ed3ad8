package bt.algorithms.graph;

import bt.collections.graphs.Graph;
import bt.collections.interfaces.IQueue;
import bt.collections.interfaces.List;
import bt.collections.iterators.Iterator;
import bt.collections.lists.ArrayList;
import bt.collections.lists.LinkedList;
import bt.collections.queues.Queue;

public class BFS2<W>{
	private int startVert = 0;
	
	public List forAdjacentShapes(Graph<Integer,W> graph) {
		if( graph == null && graph.isEmpty())
			return new LinkedList();
		else {
			graph.resetVerticesStory();
			List retVal = new ArrayList(graph.getNumberOfVerts());	
			IQueue queueOfTrace = new Queue();
			queueOfTrace.enqueue(startVert);
			
			while(queueOfTrace.isEmpty()) {
				Integer currVert = (Integer) queueOfTrace.dequeue();
				if( !graph.isDirty(startVert)) {
					retVal.add(startVert);
					graph.setDirty(startVert, true);
					Iterator it = graph.getAdjacents(currVert).iterator();
					for( it.first(); !it.isDone(); it.next()) {
						queueOfTrace.enqueue(it.current());
					}
				}
			}
			
			return retVal;
		}
	}
}
