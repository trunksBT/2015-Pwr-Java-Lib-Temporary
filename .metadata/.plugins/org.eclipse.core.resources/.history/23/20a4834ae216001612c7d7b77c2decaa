package bt.core.algorithms.graph;

import bt.core.collections.graphs.AdjacentList;
import bt.core.collections.interfaces.List;
import bt.core.collections.iterators.Iterator;
import bt.core.collections.lists.ArrayList;
import bt.core.collections.queues.Queue;

public class BFS<W> {
	public List forAdjacentList(AdjacentList<W> graph) {
		graph.resetVerticesStory();
		ArrayList retVal = new ArrayList(graph.getNumberOfVerts());
		innerForAdjList(0, graph, retVal);
		return retVal;
	}

	private void innerForAdjList(int curr, AdjacentList<W> graph, ArrayList retVal) {
		graph.getAdjacents(curr).setDirty(true);
		Queue pathStory = new Queue();
		List adjacents = null;
		pathStory.enqueue(curr);
		while(!pathStory.isEmpty()) {
			Integer dequeued = (Integer) pathStory.dequeue();
			retVal.add(dequeued);
			adjacents = graph.getAdjacents(dequeued);
			Iterator it = adjacents.iterator();
			for(it.first(); !it.isDone(); it.next())
				if(!graph.isVerticeDirty((int) it.current())) {
					graph.getAdjacents((int) it.current()).setDirty(true);
					pathStory.enqueue(it.current());
				}
		}
	}
}
