package Bt.Tests.Core.Collections;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;

import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runners.MethodSorters;

import Bt.Core.Collections.Tuple;
import junit.framework.TestCase;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)

public class TestReduce extends TestCase {
	
	public Double[][] initMatrix()
	{
		Double[][] connectionMatrix = new Double[][]{
			  { null, 4.0, null, null,},
			  { 4.0, null, 3.0, 1.0,},
			  { null, 3.0, null, 2.0,},
			  { null, 1.0, 2.0, null,},
			};
			
			return connectionMatrix;
	}
	
	public Hashtable<String, Integer> initMapBigger()
	{
		Hashtable<String,Integer> vertices = new Hashtable<String,Integer>();
		vertices.put("A", 0);
		vertices.put("B", 1);
		vertices.put("C", 2);
		vertices.put("D", 3);
		vertices.put("E", 4);
		vertices.put("F", 5);
		vertices.put("G", 6);
		vertices.put("H", 7);
		
		return vertices;
	}
	
	List<Person> persons = Arrays.asList(
	    new Person("Max", 18),
	    new Person("Peter", 23),
	    new Person("Pamela", 23),
	    new Person("David", 12));
	  
	ArrayList<String> _dirtyVertices = new ArrayList<>();
	
	  @Test
	  public void test_FoldLeftWithAccInList()
	  {
		
		Integer ageSum = persons
			    .parallelStream()
			    .reduce(0,
			        (sum, p) -> {
			            System.out.format("accumulator: sum=%s; person=%s\n", sum, p);
			            return sum += p.age;
			        },
			        (sum1, sum2) -> {
			            System.out.format("combiner: sum1=%s; sum2=%s\n", sum1, sum2);
			            return sum1 + sum2;
			        });
		
		Integer ageSum2 = persons
			    .parallelStream()
			    .reduce(0,
			        (sum, p) -> {
			            System.out.format("accumulator: sum=%s; person=%s\n", sum, p);
			            return sum += p.age;
			        },
			        (sum1, sum2) -> {
			            System.out.format("combiner: sum1=%s; sum2=%s\n", sum1, sum2);
			            return sum1 + sum2;
			        });
	      
//	      //act
//	      double reachedVal = retVal.get().value;
		System.out.println( ageSum );
	      double expectedVal = 0.0;
	      
	      //assert
	      assertEquals(1,1);
	}
	  
//		
//		Optional<Tuple<W, S>> retVal = tupleOfVals.stream()
//			.reduce((tup1,tup2) -> tup1.compareTo(tup2) > 0 ? tup1 : tup2 );
}
