package Bt.Core.Collections;

import java.util.*;

import Bt.Core.Collections.Interfaces.IGraf;

public class IndirectedGraph<W,S> implements IGraf<W,S>{
	S[][] matrix;	
	Hashtable<W,Integer> nodes;
	ArrayList<W> vertices;

	public IndirectedGraph(Hashtable<W, Integer> aNodes,S[][] aConnectionMatrix) {
		nodes = aNodes;
		matrix = aConnectionMatrix;
	}
	
	public IndirectedGraph(ArrayList<W> aVertices,S[][] aConnectionMatrix,boolean aFlag) {
		vertices = aVertices;	
		matrix = aConnectionMatrix;	

		for(int i = 0 ; i < aVertices.size();i++)
		{
			W val = aVertices.get(i);
			int ij = 0 ;
//			nodes.put(, i);
		}	
	}

//	@SuppressWarnings("unchecked")
//	@Override
//	public List<W> Wierzcholki() {			
//
//		List<W> retVal = new ArrayList<W>();
//				
//		if(nodes!=null)		
//			retVal = new ArrayList<W>((Collection<? extends W>) (nodes.entrySet()));
//		
//		return retVal;
//	}
	
	@SuppressWarnings("unchecked")
	@Override
	public List<W> Wierzcholki() {
		List<W> retVal = new ArrayList<W>();
				
		if(vertices != null)		
			retVal = vertices;
		
		return retVal;
	}
	
	@Override
	public S Krawedz(W aW1, W aW2) {
		S retVal = null;
		
		if(!(aW1 == null || aW2 == null))
			retVal = matrix[nodes.get(aW1)][nodes.get(aW2)];
		
		return retVal;
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public List<W> Krawedzie(W aW) {
		List<W> retVal = new LinkedList<>();
		ArrayList<Integer> idxes = new ArrayList<>();
		List<Tuple<Integer,W>> entrySet = entrySetToListOfTuple();
		PriorityQueue<Tuple<Integer,W>> prioQueue = toPriorityQueue(entrySet);
		
		if(aW!=null && nodes!=null && matrix!= null)
		{						
			if(nodes.getOrDefault(aW, null) != null)
			{
				S[] connections = matrix[nodes.get(aW)];
				int len = connections.length;
				int iter = -1;
				
				while(++iter<len)
					if(connections[iter]!=null)
						idxes.add(iter);
				
				for(int i = 0 ; i < idxes.size() ;)
				{
					Tuple<Integer,W> searchedEl = prioQueue.poll();
					int searchedVerticeIdx = idxes.get(i);
										
					if(searchedVerticeIdx == searchedEl.key)
					{
						retVal.add(searchedEl.value);
						i++;
					}
				}			
			}
		}		
		return retVal;
	}
	
	public List<W> KrawedzieWithLinkedList(W aW) {
		List<W> retVal = new LinkedList<>();
		ArrayList<Integer> idxes = new ArrayList<>();
		
//		S[][] matrix;	
//		Hashtable<W,Integer> nodes;
//		ArrayList<W> vertices;
		
		if(aW!=null && nodes!=null && matrix!= null)
		{						
			if(nodes.getOrDefault(aW, null) != null)
			{
				S[] connections = matrix[nodes.get(aW)];
				int len = connections.length;
				int iter = -1;
//				
				while(++iter<len)
					if(connections[iter]!=null)
						idxes.add(iter);
//				
//				for(int i = 0 ; i < idxes.size() ;)
//				{
//					Tuple<Integer,W> searchedEl = prioQueue.poll();
//					int searchedVerticeIdx = idxes.get(i);
//										
//					if(searchedVerticeIdx == searchedEl.key)
//					{
//						retVal.add(searchedEl.value);
//						i++;
//					}
//				}			
			}
		}		
		return retVal;
	}
	
	private List<Tuple<Integer,W>> entrySetToListOfTuple()
	{
		List<Tuple<Integer,W>> retVal = new LinkedList<>();
		
		for(Map.Entry<W, Integer> entry : nodes.entrySet())
			retVal.add(new Tuple<Integer,W>(entry.getValue(),entry.getKey()));
		
		return retVal;
	}
	
	private PriorityQueue<Tuple<Integer,W>> toPriorityQueue(List<Tuple<Integer,W>> aInput)
	{
		PriorityQueue<Tuple<Integer,W>> retVal = new PriorityQueue<>();
		
		for(Tuple<Integer,W> buff : aInput)
			retVal.add(buff);
		
		return retVal;
	}
}
