package bt.collections.graphs;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Queue;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.stream.Collectors;

import bt.algorithms.interfaces.IGrafC07;
import bt.algorithms.interfaces.IGraphComponents;
import bt.algorithms.interfaces.IKrawedz;

public class GraphComponents<W,S> implements IGraphComponents<W,S>{
	
	@Override
	public List<Set<W>> spojneSkladowe(IGrafC07<W, S> graph) {
		Map<W, Boolean> czyOdwiedzone = wyzerujTabliceOdwiedzin(graph.wierzcholki());
		List<Set<W>> listaZbiorow = wypelnijKolejkeZbiorow(graph.wierzcholki());
		
		for(IKrawedz<W,S> krawedz : graph.krawedzie())
		{
			Set<W> zbiorDoPolaczenia1 = null;
			Set<W> zbiorDoPolaczenia2 = null;
			
			Set<W> zbiorPierwszy = listaZbiorow.stream()
		              .filter(it -> it.contains(krawedz.w1()))
		              .findFirst().get();
			
			Set<W> zbiorDrugi = listaZbiorow.stream()
		              .filter(it -> it.contains(krawedz.w2()))
		              .findFirst().get();
			
			listaZbiorow.remove(zbiorPierwszy);
			listaZbiorow.remove(zbiorDrugi);
			
			zbiorPierwszy.addAll(zbiorDrugi);
			
			listaZbiorow.add(zbiorPierwszy);
		}
		
		return listaZbiorow;
	}
	
	private Map<W, Boolean>  wyzerujTabliceOdwiedzin(List<W> wierzcholki)
	{
		Map<W, Boolean> czyOdwiedzone = new TreeMap<>();
		for(W wierzcholek : wierzcholki)
		{
			czyOdwiedzone.put(wierzcholek, false);
		}
		return czyOdwiedzone;
	}
	
	private List<Set<W>>  wypelnijKolejkeZbiorow(List<W> wierzcholki)
	{
		List<Set<W>> kolejkaZbiorow = new LinkedList<>();
		for(W wierzcholek : wierzcholki)
		{
			Set<W> zbiorJednoelementowy = new HashSet<W>();
			zbiorJednoelementowy.add(wierzcholek);
			kolejkaZbiorow.add(zbiorJednoelementowy);
		}
		return kolejkaZbiorow;
	}

}
