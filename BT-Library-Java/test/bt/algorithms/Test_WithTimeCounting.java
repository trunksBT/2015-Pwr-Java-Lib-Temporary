package bt.algorithms;

public class Test_WithTimeCounting {
//	//Test_MethodName_StateUnderTest_Expect_ExpectedBehavior
//	@Test
//	public void test_adjacentList_WithTime_012356874()
//	{
//	    //arrange
//		ArrayList rcVal = null;
//		Graph<Integer,String> graph = new AdjacentList<String>(mockAdjacentList);
//	    boolean rcLogic = true;
//	    final int arraySize = 1000000;
//	    int endVal = 0;
//	    java.util.ArrayList<Integer> toTimeCalc = new java.util.ArrayList<>(arraySize);
//	    //act
//	    for(int i = 0 ; i < arraySize; i++) {
//		    int start = Instant.now().getNano();
//		    rcVal = ((ArrayList) new DFS<String>()
//		    		.forAdjacentList((AdjacentList<String>) graph));
//		    int end = Instant.now().getNano();
//		    toTimeCalc.add(end-start);
//	    }
//	    for(int it :toTimeCalc)
//	    	endVal+=it;
//	    
//	    System.out.println( "TimePerform:"+ endVal / arraySize );
//	    
//	    //assert
//	    Iterator fstIt = rcVal.iterator();
//	    Iterator sndIt = mockExpVal.iterator();
//	    fstIt.first();
//	    sndIt.first();
//	    while(!fstIt.isDone() && !sndIt.isDone()) {
//	    	rcLogic &= fstIt.current().equals(sndIt.current());
//	    	fstIt.next(); sndIt.next();
//	    }
//	    assertTrue(rcLogic);
//	}
}
